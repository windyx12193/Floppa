-- Zamorozka Auto Joiner
-- Frosty-themed auto join utility for Roblox
-- Generated by ChatGPT

local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TeleportService = game:GetService("TeleportService")
local UIS = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")

local LOCAL_PLAYER = Players.LocalPlayer

local SCRIPT_NAME = "Zamorozka Auto Joiner"
local SCRIPT_VERSION = "1.0.0"

local PLACE_ID = 109983668079237
local SETTINGS_PATH = "zamorozka_autojoiner.json"
local AUTO_INJECT_URL = "https://raw.githubusercontent.com/windyx12193/Floppa/refs/heads/main/beta.lua"

local API_ENDPOINT = "https://server-eta-two-29.vercel.app"
local API_KEY = "autojoiner_3b1e6b7f_ka97bj1x_8v4ln5ja"

local MIN_POLL = 0.1
local MAX_POLL = 0.25
local ERROR_BACKOFFS = {0.2, 0.5, 1.0, 2.0}
local SERVER_TTL = 180 -- seconds
local NEW_BADGE_WINDOW = 5 -- seconds
local JOIN_RETRY_INTERVAL = 0.1

local requestImpl = (syn and syn.request) or request or http_request or (http and http.request)

local function hasFilesystem()
    return typeof(writefile) == "function" and typeof(readfile) == "function" and typeof(isfile) == "function"
end

local function deepCopy(tbl)
    local result = {}
    for k, v in pairs(tbl) do
        if type(v) == "table" then
            result[k] = deepCopy(v)
        else
            result[k] = v
        end
    end
    return result
end

local Config = {
    autoJoin = false,
    autoInject = false,
    moneyFilter = 0,
    retryAmount = 0,
    whitelist = {},
    blacklist = {}
}

local function parseCSV(text)
    local list = {}
    if not text or text == "" then
        return list
    end
    for token in string.gmatch(text, "[^,]+") do
        local trimmed = token:gsub("^%s+", ""):gsub("%s+$", "")
        if trimmed ~= "" then
            table.insert(list, trimmed)
        end
    end
    return list
end

local function saveConfig()
    if not hasFilesystem() then
        return
    end
    local ok, encoded = pcall(HttpService.JSONEncode, HttpService, Config)
    if ok then
        pcall(writefile, SETTINGS_PATH, encoded)
    end
end

local function loadConfig()
    if not hasFilesystem() or not isfile(SETTINGS_PATH) then
        return
    end
    local ok, raw = pcall(readfile, SETTINGS_PATH)
    if not ok or type(raw) ~= "string" then
        return
    end
    local okDecode, decoded = pcall(HttpService.JSONDecode, HttpService, raw)
    if not okDecode or type(decoded) ~= "table" then
        return
    end
    Config.autoJoin = decoded.autoJoin == true
    Config.autoInject = decoded.autoInject == true
    Config.moneyFilter = tonumber(decoded.moneyFilter) or 0
    Config.retryAmount = math.max(0, tonumber(decoded.retryAmount) or 0)
    Config.whitelist = type(decoded.whitelist) == "table" and decoded.whitelist or {}
    Config.blacklist = type(decoded.blacklist) == "table" and decoded.blacklist or {}
end

loadConfig()

local function queueAutoInject()
    local payload = string.format("loadstring(game:HttpGet(%q, true))()", AUTO_INJECT_URL)
    local queue = queue_on_teleport or (syn and syn.queue_on_teleport) or (fluxus and fluxus.queue_on_teleport)
    if queue then
        queue(payload)
    end
end

local function normalizeMoney(str)
    if not str then return 0 end
    str = str:gsub("%$", ""):gsub("/s", ""):gsub("/S", "")
    str = str:gsub("%s", "")
    local mult = 1
    local suffix = string.sub(str, -1):lower()
    if suffix == "k" then
        mult = 1e3
        str = string.sub(str, 1, -2)
    elseif suffix == "m" then
        mult = 1e6
        str = string.sub(str, 1, -2)
    elseif suffix == "b" then
        mult = 1e9
        str = string.sub(str, 1, -2)
    end
    local value = tonumber(str)
    if not value then
        return 0
    end
    return math.floor(value * mult + 0.5)
end

local function trimZeros(str)
    str = str:gsub("(%..-?)0+$", "%1")
    str = str:gsub("%.$", "")
    return str
end

local function formatMoneyShort(amount)
    if amount >= 1e9 then
        return trimZeros(string.format("%.2f", amount / 1e9)) .. "b/s"
    elseif amount >= 1e6 then
        return trimZeros(string.format("%.2f", amount / 1e6)) .. "m/s"
    elseif amount >= 1e3 then
        return trimZeros(string.format("%.2f", amount / 1e3)) .. "k/s"
    else
        return string.format("%d/s", amount)
    end
end

local function formatMoneyInput(amount)
    if amount <= 0 then
        return ""
    elseif amount >= 1e9 then
        return trimZeros(string.format("%.2f", amount / 1e9)) .. "b"
    elseif amount >= 1e6 then
        return trimZeros(string.format("%.2f", amount / 1e6)) .. "m"
    elseif amount >= 1e3 then
        return trimZeros(string.format("%.2f", amount / 1e3)) .. "k"
    else
        return tostring(amount)
    end
end

local function parseLine(line)
    if not line or line == "" then
        return nil
    end
    line = line:gsub("%*", "")
    local name, moneyStr, playersStr, jobId, timestamp = line:match("^%s*(.-)%s*|%s*%$?([^|]+)/s%s*|%s*([^|]+)%s*|%s*([%w%-]+)%s*|%s*(%d+%.%d+%.%d+,%s*%d+:%d+:%d+)%s*$")
    if not (name and moneyStr and playersStr and jobId and timestamp) then
        name, moneyStr, playersStr, jobId, timestamp = line:match("^%s*(.-)%s*|%s*%$?([^|]+)/s%s*|%s*([^|]+)%s*|%s*([%w%-]+)%s*|%s*(.-)%s*$")
        if not (name and moneyStr and playersStr and jobId and timestamp) then
            return nil
        end
    end
    local players, maxPlayers = playersStr:match("(%d+)%s*/%s*(%d+)")
    if not (players and maxPlayers) then
        return nil
    end
    players = tonumber(players)
    maxPlayers = tonumber(maxPlayers)
    if not (players and maxPlayers) then
        return nil
    end
    local money = normalizeMoney(moneyStr)
    return {
        name = name,
        moneyPerSec = money,
        players = players,
        maxPlayers = maxPlayers,
        jobId = jobId,
        timestamp = timestamp,
    }
end

local function compareMoneyDesc(a, b)
    if a.moneyPerSec ~= b.moneyPerSec then
        return a.moneyPerSec > b.moneyPerSec
    end
    return a.firstSeen < b.firstSeen
end

local Servers = {}
local ServerOrder = {}

local function removeServer(jobId)
    local entry = Servers[jobId]
    if not entry then return end
    Servers[jobId] = nil
    for i = #ServerOrder, 1, -1 do
        if ServerOrder[i] == jobId then
            table.remove(ServerOrder, i)
            break
        end
    end
    if entry.card then
        task.spawn(function()
            local card = entry.card
            if card and card.Parent then
                TweenService:Create(card, TweenInfo.new(0.25, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {
                    BackgroundTransparency = 1
                }):Play()
                for _, child in ipairs(card:GetDescendants()) do
                    if child:IsA("TextLabel") or child:IsA("TextButton") then
                        TweenService:Create(child, TweenInfo.new(0.25, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {
                            TextTransparency = 1,
                            BackgroundTransparency = 1
                        }):Play()
                    elseif child:IsA("Frame") then
                        TweenService:Create(child, TweenInfo.new(0.25, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {
                            BackgroundTransparency = 1
                        }):Play()
                    end
                end
                task.wait(0.28)
            end
            if card and card.Parent then
                card:Destroy()
            end
        end)
    end
end

local function playersFull(entry)
    return entry.players >= entry.maxPlayers
end

local function shouldDisplay(entry)
    local now = os.clock()
    if now - entry.lastSeen > SERVER_TTL then
        return false
    end
    return true
end

local function meetsFilters(entry)
    if entry.moneyPerSec < (Config.moneyFilter or 0) then
        return false
    end
    local wl = Config.whitelist
    if wl and #wl > 0 then
        local match = false
        for _, name in ipairs(wl) do
            if string.lower(name) == string.lower(entry.name) then
                match = true
                break
            end
        end
        if not match then
            return false
        end
    else
        local bl = Config.blacklist
        if bl and #bl > 0 then
            for _, name in ipairs(bl) do
                if string.lower(name) == string.lower(entry.name) then
                    return false
                end
            end
        end
    end
    return true
end

local function findBestServer()
    local now = os.clock()
    local newCandidates = {}
    local oldCandidates = {}
    for _, jobId in ipairs(ServerOrder) do
        local entry = Servers[jobId]
        if entry and meetsFilters(entry) then
            if playersFull(entry) then
                -- allow for retry logic to handle full servers later
                table.insert(oldCandidates, entry)
            else
                if now - entry.firstSeen <= NEW_BADGE_WINDOW then
                    table.insert(newCandidates, entry)
                else
                    table.insert(oldCandidates, entry)
                end
            end
        end
    end
    table.sort(newCandidates, compareMoneyDesc)
    table.sort(oldCandidates, compareMoneyDesc)
    if #newCandidates > 0 then
        return newCandidates[1]
    end
    return oldCandidates[1]
end

local ActiveJoin = {
    retryTask = nil,
    remaining = 0,
    targetJobId = nil,
    _accumulator = 0
}

local function stopRetry()
    if ActiveJoin.retryTask then
        ActiveJoin.retryTask:Disconnect()
        ActiveJoin.retryTask = nil
    end
    ActiveJoin.remaining = 0
    ActiveJoin.targetJobId = nil
    ActiveJoin._accumulator = 0
end

local setAutoJoinToggleFn
local setAutoInjectToggleFn

local function setAutoJoin(state)
    Config.autoJoin = state == true
    if setAutoJoinToggleFn then
        setAutoJoinToggleFn(Config.autoJoin)
    end
    if not Config.autoJoin then
        stopRetry()
    end
    saveConfig()
end

local function setAutoInject(state)
    Config.autoInject = state == true
    if setAutoInjectToggleFn then
        setAutoInjectToggleFn(Config.autoInject)
    end
    saveConfig()
end

local function attemptTeleport(entry, isRetry)
    if not entry then
        return false
    end
    if Config.autoInject then
        queueAutoInject()
    end
    local success, result = pcall(function()
        return TeleportService:TeleportToPlaceInstance(PLACE_ID, entry.jobId, LOCAL_PLAYER)
    end)
    if success then
        setAutoJoin(false)
        stopRetry()
        return true
    end
    warn(string.format("Teleport failed: %s", tostring(result)))
    if not isRetry and Config.retryAmount > 0 then
        ActiveJoin.remaining = Config.retryAmount
        ActiveJoin.targetJobId = entry.jobId
        ActiveJoin._accumulator = 0
        if ActiveJoin.retryTask then
            ActiveJoin.retryTask:Disconnect()
        end
        local count = 0
        ActiveJoin.retryTask = RunService.Heartbeat:Connect(function(dt)
            ActiveJoin._accumulator = (ActiveJoin._accumulator or 0) + dt
            if ActiveJoin._accumulator < JOIN_RETRY_INTERVAL then
                return
            end
            ActiveJoin._accumulator = ActiveJoin._accumulator - JOIN_RETRY_INTERVAL
            if ActiveJoin.remaining <= 0 then
                stopRetry()
                return
            end
            ActiveJoin.remaining -= 1
            count += 1
            print(string.format("join retry %d/%d", count, Config.retryAmount))
            local target = Servers[ActiveJoin.targetJobId]
            if target then
                local ok = attemptTeleport(target, true)
                if ok then
                    stopRetry()
                end
            else
                stopRetry()
            end
        end)
    end
    return false
end

local function handleAutoJoin()
    if not Config.autoJoin then
        return
    end
    local best = findBestServer()
    if not best then
        return
    end
    if playersFull(best) then
        if Config.retryAmount > 0 and ActiveJoin.retryTask == nil then
            attemptTeleport(best, false)
        end
        return
    end
    attemptTeleport(best, false)
end

-- UI Creation
local function findGuiParent()
    local ok, gui = pcall(function()
        if gethui then
            return gethui()
        end
    end)
    if ok and gui then
        return gui
    end
    local ok2, coreGui = pcall(function()
        return game:GetService("CoreGui")
    end)
    if ok2 and coreGui then
        return coreGui
    end
    return LOCAL_PLAYER and LOCAL_PLAYER:WaitForChild("PlayerGui")
end

local rootParent = findGuiParent()

local oldGui = rootParent:FindFirstChild("ZamorozkaAutoJoinerGui")
if oldGui then
    oldGui:Destroy()
end

local screenGui = Instance.new("ScreenGui")
screenGui.IgnoreGuiInset = true
screenGui.Name = "ZamorozkaAutoJoinerGui"
screenGui.ResetOnSpawn = false
screenGui.DisplayOrder = 9999
screenGui.Parent = rootParent

local frostingColor = Color3.fromRGB(225, 234, 244)
local accentColor = Color3.fromRGB(142, 167, 204)
local panelColor = Color3.fromRGB(210, 220, 233)
local textColor = Color3.fromRGB(30, 42, 58)
local greenColor = Color3.fromRGB(70, 170, 110)
local blueColor = Color3.fromRGB(70, 120, 200)
local newCardColor = Color3.fromRGB(240, 248, 255)

local mainFrame = Instance.new("Frame")
mainFrame.Name = "MainFrame"
mainFrame.BackgroundColor3 = frostingColor
mainFrame.BackgroundTransparency = 0.15
mainFrame.AnchorPoint = Vector2.new(0.5, 0.5)
mainFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
mainFrame.Size = UDim2.new(0.62, 0, 0.7, 0)
mainFrame.Parent = screenGui

local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(0, 18)
corner.Parent = mainFrame

local stroke = Instance.new("UIStroke")
stroke.Color = accentColor
stroke.Thickness = 1.5
stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
stroke.Parent = mainFrame

local topBar = Instance.new("Frame")
topBar.Name = "TopBar"
topBar.BackgroundTransparency = 0.2
topBar.BackgroundColor3 = panelColor
topBar.Size = UDim2.new(1, 0, 0.12, 0)
topBar.Parent = mainFrame

local topCorner = Instance.new("UICorner")
topCorner.CornerRadius = UDim.new(0, 18)
topCorner.Parent = topBar

local titleLabel = Instance.new("TextLabel")
titleLabel.BackgroundTransparency = 1
titleLabel.Text = SCRIPT_NAME

local function setFont(instance, weight)
    local ok = pcall(function()
        if weight == "bold" then
            instance.Font = Enum.Font.GothamBold
        elseif weight == "medium" then
            instance.Font = Enum.Font.GothamMedium
        else
            instance.Font = Enum.Font.Gotham
        end
    end)
    if not ok then
        instance.Font = Enum.Font.SourceSans
    end
end

setFont(titleLabel, "bold")
titleLabel.TextSize = 32
titleLabel.TextColor3 = textColor
titleLabel.Size = UDim2.new(1, -40, 1, 0)
titleLabel.Position = UDim2.new(0, 20, 0, 0)
titleLabel.TextXAlignment = Enum.TextXAlignment.Left
titleLabel.Parent = topBar

local versionLabel = Instance.new("TextLabel")
versionLabel.BackgroundTransparency = 1
versionLabel.Text = "v" .. SCRIPT_VERSION
setFont(versionLabel, "medium")
versionLabel.TextSize = 18
versionLabel.TextColor3 = textColor
versionLabel.Size = UDim2.new(0, 100, 1, 0)
versionLabel.Position = UDim2.new(1, -120, 0, 0)
versionLabel.TextXAlignment = Enum.TextXAlignment.Right
versionLabel.Parent = topBar

local contentFrame = Instance.new("Frame")
contentFrame.BackgroundTransparency = 1
contentFrame.Size = UDim2.new(1, 0, 0.88, 0)
contentFrame.Position = UDim2.new(0, 0, 0.12, 0)
contentFrame.Parent = mainFrame

local leftPanel = Instance.new("Frame")
leftPanel.Name = "LeftPanel"
leftPanel.BackgroundColor3 = panelColor
leftPanel.BackgroundTransparency = 0.25
leftPanel.Size = UDim2.new(0.3, -12, 1, -24)
leftPanel.Position = UDim2.new(0, 12, 0, 12)
leftPanel.Parent = contentFrame

local leftCorner = Instance.new("UICorner")
leftCorner.CornerRadius = UDim.new(0, 14)
leftCorner.Parent = leftPanel

local leftStroke = Instance.new("UIStroke")
leftStroke.Color = accentColor
leftStroke.Thickness = 1
leftStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
leftStroke.Parent = leftPanel

local leftList = Instance.new("UIListLayout")
leftList.Padding = UDim.new(0, 10)
leftList.FillDirection = Enum.FillDirection.Vertical
leftList.HorizontalAlignment = Enum.HorizontalAlignment.Center
leftList.SortOrder = Enum.SortOrder.LayoutOrder
leftList.Parent = leftPanel

local leftPadding = Instance.new("UIPadding")
leftPadding.PaddingTop = UDim.new(0, 18)
leftPadding.PaddingBottom = UDim.new(0, 18)
leftPadding.PaddingLeft = UDim.new(0, 18)
leftPadding.PaddingRight = UDim.new(0, 18)
leftPadding.Parent = leftPanel

local rightPanel = Instance.new("Frame")
rightPanel.Name = "RightPanel"
rightPanel.BackgroundColor3 = panelColor
rightPanel.BackgroundTransparency = 0.2
rightPanel.Size = UDim2.new(0.7, -24, 1, -24)
rightPanel.Position = UDim2.new(0.3, 12, 0, 12)
rightPanel.Parent = contentFrame

local rightCorner = Instance.new("UICorner")
rightCorner.CornerRadius = UDim.new(0, 14)
rightCorner.Parent = rightPanel

local rightStroke = Instance.new("UIStroke")
rightStroke.Color = accentColor
rightStroke.Thickness = 1
rightStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
rightStroke.Parent = rightPanel

local rightPadding = Instance.new("UIPadding")
rightPadding.PaddingTop = UDim.new(0, 16)
rightPadding.PaddingBottom = UDim.new(0, 16)
rightPadding.PaddingLeft = UDim.new(0, 18)
rightPadding.PaddingRight = UDim.new(0, 18)
rightPadding.Parent = rightPanel

local serverList = Instance.new("ScrollingFrame")
serverList.Name = "ServerList"
serverList.BackgroundTransparency = 1
serverList.BorderSizePixel = 0
serverList.CanvasSize = UDim2.new()
serverList.ScrollBarThickness = 6
serverList.ScrollingDirection = Enum.ScrollingDirection.Y
serverList.AutomaticCanvasSize = Enum.AutomaticSize.Y
serverList.Size = UDim2.new(1, 0, 1, 0)
serverList.Parent = rightPanel

local listLayout = Instance.new("UIListLayout")
listLayout.Padding = UDim.new(0, 10)
listLayout.SortOrder = Enum.SortOrder.LayoutOrder
listLayout.Parent = serverList

local function createSectionLabel(text)
    local label = Instance.new("TextLabel")
    label.BackgroundTransparency = 1
    label.Size = UDim2.new(1, 0, 0, 28)
    label.Text = text
    setFont(label, "bold")
    label.TextSize = 18
    label.TextColor3 = textColor
    label.TextXAlignment = Enum.TextXAlignment.Left
    return label
end

local function createToggle(name, initialValue, callback)
    local holder = Instance.new("Frame")
    holder.BackgroundColor3 = frostingColor
    holder.BackgroundTransparency = 0.1
    holder.Size = UDim2.new(1, 0, 0, 48)
    holder.LayoutOrder = 10

    local cornerInst = Instance.new("UICorner")
    cornerInst.CornerRadius = UDim.new(0, 12)
    cornerInst.Parent = holder

    local strokeInst = Instance.new("UIStroke")
    strokeInst.Color = accentColor
    strokeInst.Thickness = 1
    strokeInst.Parent = holder

    local label = Instance.new("TextLabel")
    label.BackgroundTransparency = 1
    label.Size = UDim2.new(1, -90, 1, 0)
    label.Position = UDim2.new(0, 12, 0, 0)
    label.Text = name
    setFont(label, "medium")
    label.TextSize = 18
    label.TextColor3 = textColor
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.Parent = holder

    local button = Instance.new("TextButton")
    button.AutoButtonColor = false
    button.Text = ""
    button.Size = UDim2.new(0, 56, 0, 28)
    button.Position = UDim2.new(1, -64, 0.5, -14)
    button.BackgroundColor3 = Color3.fromRGB(200, 210, 220)
    button.Parent = holder

    local buttonCorner = Instance.new("UICorner")
    buttonCorner.CornerRadius = UDim.new(0, 14)
    buttonCorner.Parent = button

    local knob = Instance.new("Frame")
    knob.Size = UDim2.new(0, 24, 0, 24)
    knob.Position = UDim2.new(0, 2, 0.5, -12)
    knob.BackgroundColor3 = Color3.fromRGB(180, 190, 200)
    knob.Parent = button

    local knobCorner = Instance.new("UICorner")
    knobCorner.CornerRadius = UDim.new(0, 12)
    knobCorner.Parent = knob

    local toggled = initialValue == true

    local function applyState(isOn, instant)
        toggled = isOn
        local goalPosition = isOn and UDim2.new(1, -26, 0.5, -12) or UDim2.new(0, 2, 0.5, -12)
        local goalColor = isOn and greenColor or Color3.fromRGB(180, 190, 200)
        local bgColor = isOn and Color3.fromRGB(210, 240, 220) or Color3.fromRGB(200, 210, 220)
        if instant then
            knob.Position = goalPosition
            knob.BackgroundColor3 = goalColor
            button.BackgroundColor3 = bgColor
        else
            TweenService:Create(knob, TweenInfo.new(0.15, Enum.EasingStyle.Sine), {Position = goalPosition, BackgroundColor3 = goalColor}):Play()
            TweenService:Create(button, TweenInfo.new(0.15, Enum.EasingStyle.Sine), {BackgroundColor3 = bgColor}):Play()
        end
    end

    applyState(toggled, true)

    button.MouseButton1Click:Connect(function()
        applyState(not toggled, false)
        if callback then
            callback(toggled)
        end
    end)

    return holder, function(value)
        applyState(value == true, true)
    end
end

local function createInput(name, placeholder, defaultText, numeric, callback)
    local holder = Instance.new("Frame")
    holder.BackgroundColor3 = frostingColor
    holder.BackgroundTransparency = 0.1
    holder.Size = UDim2.new(1, 0, 0, 78)

    local cornerInst = Instance.new("UICorner")
    cornerInst.CornerRadius = UDim.new(0, 12)
    cornerInst.Parent = holder

    local strokeInst = Instance.new("UIStroke")
    strokeInst.Color = accentColor
    strokeInst.Thickness = 1
    strokeInst.Parent = holder

    local title = Instance.new("TextLabel")
    title.BackgroundTransparency = 1
    title.Size = UDim2.new(1, -12, 0, 24)
    title.Position = UDim2.new(0, 12, 0, 10)
    title.Text = name
    title.TextColor3 = textColor
    setFont(title, "medium")
    title.TextXAlignment = Enum.TextXAlignment.Left
    title.TextSize = 18
    title.Parent = holder

    local input = Instance.new("TextBox")
    input.ClearTextOnFocus = false
    input.TextTruncate = Enum.TextTruncate.AtEnd
    input.TextSize = 18
    input.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    input.Size = UDim2.new(1, -24, 0, 30)
    input.Position = UDim2.new(0, 12, 0, 40)
    input.PlaceholderText = placeholder or ""
    input.Text = defaultText or ""
    input.TextColor3 = textColor
    setFont(input, "medium")
    input.Parent = holder

    local boxCorner = Instance.new("UICorner")
    boxCorner.CornerRadius = UDim.new(0, 10)
    boxCorner.Parent = input

    input.FocusLost:Connect(function(enterPressed)
        local text = input.Text
        if numeric then
            local sanitized = text:gsub("[^%d%.,kKmMbB]", "")
            if sanitized == "" then
                sanitized = "0"
            end
            local number = normalizeMoney(sanitized)
            if name == "Join Retry Amount" then
                number = math.max(0, tonumber(text) or number)
            end
            if callback then
                callback(text, number)
            end
        else
            if callback then
                callback(text)
            end
        end
        saveConfig()
    end)

    return holder, input
end

local autoJoinToggle
autoJoinToggle, setAutoJoinToggleFn = createToggle("Auto Join", Config.autoJoin, function(value)
    setAutoJoin(value)
    if value then
        handleAutoJoin()
    end
end)
autoJoinToggle.LayoutOrder = 1
autoJoinToggle.Parent = leftPanel

local autoInjectToggle
autoInjectToggle, setAutoInjectToggleFn = createToggle("Auto Inject", Config.autoInject, function(value)
    setAutoInject(value)
end)
autoInjectToggle.LayoutOrder = 2
autoInjectToggle.Parent = leftPanel

local moneyInputHolder, moneyInput = createInput("Money filter (m/s)", "e.g. 5m", formatMoneyInput(Config.moneyFilter), false, function(raw)
    local value = normalizeMoney(raw)
    Config.moneyFilter = value
    moneyInput.Text = formatMoneyInput(value)
    saveConfig()
end)
moneyInputHolder.LayoutOrder = 3
moneyInputHolder.Parent = leftPanel

local retryInputHolder, retryInput = createInput("Join Retry Amount", tostring(Config.retryAmount), tostring(Config.retryAmount), true, function(text, parsed)
    local numeric = tonumber(text)
    if not numeric then
        numeric = tonumber(parsed) or 0
    end
    if numeric < 0 then
        warn("Join retry amount cannot be negative; clamping to 0")
        numeric = 0
    end
    numeric = math.floor(numeric)
    Config.retryAmount = math.max(0, numeric)
    retryInput.Text = tostring(Config.retryAmount)
    saveConfig()
end)
retryInputHolder.LayoutOrder = 4
retryInputHolder.Parent = leftPanel

local whitelistHolder, whitelistInput = createInput("Whitelist (CSV)", "name1,name2", table.concat(Config.whitelist, ","), false, function(text)
    Config.whitelist = parseCSV(text)
    saveConfig()
end)
whitelistHolder.LayoutOrder = 5
whitelistHolder.Parent = leftPanel

local blacklistHolder, blacklistInput = createInput("Blacklist (CSV)", "name1,name2", table.concat(Config.blacklist, ","), false, function(text)
    Config.blacklist = parseCSV(text)
    saveConfig()
end)
blacklistHolder.LayoutOrder = 6
blacklistHolder.Parent = leftPanel

setAutoJoinToggleFn(Config.autoJoin)
setAutoInjectToggleFn(Config.autoInject)

local function createServerCard(entry)
    local card = Instance.new("Frame")
    card.BackgroundColor3 = frostingColor
    card.BackgroundTransparency = 0.05
    card.Size = UDim2.new(1, 0, 0, 74)
    card.Parent = serverList

    local cardCorner = Instance.new("UICorner")
    cardCorner.CornerRadius = UDim.new(0, 12)
    cardCorner.Parent = card

    local cardStroke = Instance.new("UIStroke")
    cardStroke.Color = accentColor
    cardStroke.Thickness = 1
    cardStroke.Parent = card

    local nameLabel = Instance.new("TextLabel")
    nameLabel.BackgroundTransparency = 1
    nameLabel.Size = UDim2.new(0.4, 0, 0.5, 0)
    nameLabel.Position = UDim2.new(0, 16, 0, 8)
    nameLabel.Text = entry.name
    nameLabel.TextColor3 = textColor
    setFont(nameLabel, "bold")
    nameLabel.TextSize = 20
    nameLabel.TextXAlignment = Enum.TextXAlignment.Left
    nameLabel.Parent = card

    local moneyLabel = Instance.new("TextLabel")
    moneyLabel.BackgroundTransparency = 1
    moneyLabel.Size = UDim2.new(0.2, 0, 0.4, 0)
    moneyLabel.Position = UDim2.new(0, 16, 0.55, 0)
    moneyLabel.Text = formatMoneyShort(entry.moneyPerSec)
    moneyLabel.TextColor3 = greenColor
    setFont(moneyLabel, "medium")
    moneyLabel.TextSize = 18
    moneyLabel.TextXAlignment = Enum.TextXAlignment.Left
    moneyLabel.Parent = card

    local playersLabel = Instance.new("TextLabel")
    playersLabel.BackgroundTransparency = 1
    playersLabel.Size = UDim2.new(0.2, 0, 0.4, 0)
    playersLabel.Position = UDim2.new(0.35, 0, 0.55, 0)
    playersLabel.Text = string.format("%d/%d", entry.players, entry.maxPlayers)
    playersLabel.TextColor3 = blueColor
    setFont(playersLabel, "medium")
    playersLabel.TextSize = 18
    playersLabel.TextXAlignment = Enum.TextXAlignment.Left
    playersLabel.Parent = card

    local joinButton = Instance.new("TextButton")
    joinButton.Text = "Join"
    joinButton.Size = UDim2.new(0, 100, 0, 36)
    joinButton.Position = UDim2.new(1, -116, 0.5, -18)
    joinButton.BackgroundColor3 = Color3.fromRGB(180, 220, 195)
    joinButton.TextColor3 = greenColor
    setFont(joinButton, "bold")
    joinButton.TextSize = 20
    joinButton.AutoButtonColor = false
    joinButton.Parent = card

    local joinCorner = Instance.new("UICorner")
    joinCorner.CornerRadius = UDim.new(0, 12)
    joinCorner.Parent = joinButton

    local newBadge = Instance.new("TextLabel")
    newBadge.BackgroundColor3 = Color3.fromRGB(220, 245, 255)
    newBadge.BackgroundTransparency = 0.2
    newBadge.Size = UDim2.new(0, 60, 0, 24)
    newBadge.Position = UDim2.new(1, -184, 0, 12)
    newBadge.Text = "NEW"
    newBadge.TextColor3 = blueColor
    setFont(newBadge, "bold")
    newBadge.TextSize = 16
    newBadge.Visible = true
    newBadge.Parent = card

    local badgeCorner = Instance.new("UICorner")
    badgeCorner.CornerRadius = UDim.new(0, 12)
    badgeCorner.Parent = newBadge

    joinButton.MouseButton1Click:Connect(function()
        attemptTeleport(entry, false)
    end)

    return {
        frame = card,
        nameLabel = nameLabel,
        moneyLabel = moneyLabel,
        playersLabel = playersLabel,
        joinButton = joinButton,
        newBadge = newBadge
    }
end

local function updateServerCard(entry)
    if not entry.card then
        entry.card = createServerCard(entry)
    end
    local ui = entry.card
    ui.nameLabel.Text = entry.name
    ui.moneyLabel.Text = formatMoneyShort(entry.moneyPerSec)
    ui.playersLabel.Text = string.format("%d/%d", entry.players, entry.maxPlayers)
    local now = os.clock()
    ui.newBadge.Visible = now - entry.firstSeen <= NEW_BADGE_WINDOW
    if ui.frame then
        if now - entry.firstSeen <= NEW_BADGE_WINDOW then
            ui.frame.BackgroundColor3 = newCardColor
        else
            ui.frame.BackgroundColor3 = frostingColor
        end
    end
    if playersFull(entry) then
        ui.joinButton.BackgroundColor3 = Color3.fromRGB(230, 200, 200)
        ui.joinButton.TextColor3 = Color3.fromRGB(200, 100, 100)
    else
        ui.joinButton.BackgroundColor3 = Color3.fromRGB(180, 220, 195)
        ui.joinButton.TextColor3 = greenColor
    end
end

local function refreshServerList()
    local toRemove = {}
    for index, jobId in ipairs(ServerOrder) do
        local entry = Servers[jobId]
        if entry and shouldDisplay(entry) then
            updateServerCard(entry)
            if entry.card and entry.card.frame then
                entry.card.frame.LayoutOrder = index
            end
        else
            table.insert(toRemove, jobId)
        end
    end
    for _, jobId in ipairs(toRemove) do
        removeServer(jobId)
    end
end

local function ingestData(raw)
    local now = os.clock()
    local processed = {}
    for name, moneyStr, playersStr, jobId, timestamp in raw:gmatch("%s*(.-)%s*|%s*%$?([^|]+)/s%s*|%s*([^|]+)%s*|%s*([%w%-]+)%s*|%s*(%d+%.%d+%.%d+,%s*%d+:%d+:%d+)") do
        name = name:gsub("%*", "")
        moneyStr = moneyStr:gsub("%*", "")
        playersStr = playersStr:gsub("%*", "")
        timestamp = timestamp:gsub("%*", "")
        local players, maxPlayers = playersStr:match("(%d+)%s*/%s*(%d+)")
        players = tonumber(players)
        maxPlayers = tonumber(maxPlayers)
        if players and maxPlayers then
            local money = normalizeMoney(moneyStr)
            local parsed = {
                name = name,
                moneyPerSec = money,
                players = players,
                maxPlayers = maxPlayers,
                jobId = jobId,
                timestamp = timestamp
            }
            processed[jobId] = true
            local entry = Servers[jobId]
            if entry then
                entry.name = parsed.name
                entry.moneyPerSec = parsed.moneyPerSec
                entry.players = parsed.players
                entry.maxPlayers = parsed.maxPlayers
                entry.timestamp = parsed.timestamp
                entry.lastSeen = now
            else
                entry = {
                    name = parsed.name,
                    moneyPerSec = parsed.moneyPerSec,
                    players = parsed.players,
                    maxPlayers = parsed.maxPlayers,
                    jobId = parsed.jobId,
                    timestamp = parsed.timestamp,
                    firstSeen = now,
                    lastSeen = now
                }
                Servers[jobId] = entry
                table.insert(ServerOrder, jobId)
            end
        end
    end
    for line in raw:gmatch("[^\n]+") do
        local parsed = parseLine(line)
        if parsed and not processed[parsed.jobId] then
            processed[parsed.jobId] = true
            local entry = Servers[parsed.jobId]
            if entry then
                entry.name = parsed.name
                entry.moneyPerSec = parsed.moneyPerSec
                entry.players = parsed.players
                entry.maxPlayers = parsed.maxPlayers
                entry.timestamp = parsed.timestamp
                entry.lastSeen = now
            else
                entry = {
                    name = parsed.name,
                    moneyPerSec = parsed.moneyPerSec,
                    players = parsed.players,
                    maxPlayers = parsed.maxPlayers,
                    jobId = parsed.jobId,
                    timestamp = parsed.timestamp,
                    firstSeen = now,
                    lastSeen = now
                }
                Servers[parsed.jobId] = entry
                table.insert(ServerOrder, parsed.jobId)
            end
        end
    end
    table.sort(ServerOrder, function(a, b)
        return Servers[a].moneyPerSec > Servers[b].moneyPerSec
    end)
end

local lastPoll = 0
local networkInterval = MIN_POLL
local frameInterval = MIN_POLL
local frameTimeAverage = MIN_POLL
local errorCount = 0

local statusBanner

local function ensureBanner()
    if statusBanner then
        return statusBanner
    end
    local banner = Instance.new("TextLabel")
    banner.Size = UDim2.new(1, 0, 0, 28)
    banner.Position = UDim2.new(0, 0, 0, -30)
    banner.BackgroundTransparency = 0.6
    banner.BackgroundColor3 = Color3.fromRGB(255, 120, 120)
    banner.TextColor3 = Color3.fromRGB(255, 255, 255)
    banner.TextSize = 16
    banner.Text = ""
    banner.Visible = false
    setFont(banner, "medium")
    banner.Parent = mainFrame
    statusBanner = banner
    return banner
end

local function setBanner(text)
    local banner = ensureBanner()
    if not text or text == "" then
        banner.Visible = false
        return
    end
    banner.Text = text
    banner.Visible = true
end

local pollHeartbeat

local function startPolling()
    if pollHeartbeat then
        pollHeartbeat:Disconnect()
    end
    pollHeartbeat = RunService.Heartbeat:Connect(function(dt)
        frameTimeAverage = frameTimeAverage * 0.9 + dt * 0.1
        if frameTimeAverage > 0.2 then
            frameInterval = 0.25
        elseif frameTimeAverage > 0.15 then
            frameInterval = 0.2
        else
            frameInterval = MIN_POLL
        end
        local now = os.clock()
        local interval = math.max(networkInterval, frameInterval)
        if now - lastPoll < interval then
            return
        end
        lastPoll = now
        if not requestImpl then
            setBanner("No request() implementation available")
            networkInterval = 5
            return
        end
        local headers = {
            ["Authorization"] = API_KEY
        }
        local response = requestImpl({
            Url = API_ENDPOINT,
            Method = "GET",
            Headers = headers
        })
        if not response or response.StatusCode ~= 200 then
            errorCount += 1
            local backoff = ERROR_BACKOFFS[math.clamp(errorCount, 1, #ERROR_BACKOFFS)]
            networkInterval = backoff
            local status = response and (response.StatusMessage or response.StatusCode) or "connection error"
            setBanner("Network error: " .. tostring(status))
            return
        end
        setBanner("")
        errorCount = 0
        networkInterval = MIN_POLL
        ingestData(response.Body or "")
        refreshServerList()
        handleAutoJoin()
    end)
end

startPolling()

local function cleanupExpired()
    while true do
        task.wait(1)
        local now = os.clock()
        for _, jobId in ipairs(deepCopy(ServerOrder)) do
            local entry = Servers[jobId]
            if entry and now - entry.lastSeen > SERVER_TTL then
                removeServer(jobId)
            end
        end
        refreshServerList()
    end
end

task.spawn(cleanupExpired)

UIS.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then
        return
    end
    if input.KeyCode == Enum.KeyCode.K then
        mainFrame.Visible = not mainFrame.Visible
    end
end)

local function fadeIn()
    mainFrame.BackgroundTransparency = 1
    topBar.BackgroundTransparency = 1
    leftPanel.BackgroundTransparency = 1
    rightPanel.BackgroundTransparency = 1
    TweenService:Create(mainFrame, TweenInfo.new(0.3, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {BackgroundTransparency = 0.15}):Play()
    TweenService:Create(topBar, TweenInfo.new(0.3, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {BackgroundTransparency = 0.2}):Play()
    TweenService:Create(leftPanel, TweenInfo.new(0.3, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {BackgroundTransparency = 0.25}):Play()
    TweenService:Create(rightPanel, TweenInfo.new(0.3, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {BackgroundTransparency = 0.2}):Play()
end

fadeIn()

refreshServerList()
handleAutoJoin()
